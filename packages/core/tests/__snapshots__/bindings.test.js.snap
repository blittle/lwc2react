// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Class bindings should add observable membrane for assignments 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./test.html\\";

class Test extends React.Component {
  constructor(...args) {
    super(...args);

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({
        setA: this.setA
      });
    }

    this.template = React.createRef();
    this.__s.a = 1;
  }

  setA() {
    this.__s.a = this.__s.a + 1;
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default Test;"
`;

exports[`Class bindings should add observable membrane for basic bindings 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./test.html\\";

class Test extends React.Component {
  constructor(...args) {
    super(...args);

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({
        setA: this.setA
      });
    }

    this.template = React.createRef();
    this.__s.a = 1;
  }

  setA() {
    this.__s.a++;
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default Test;"
`;

exports[`Class bindings should compile @api props 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./app.html\\";

class App extends React.Component {
  constructor(...args) {
    super(...args);

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({});
    }

    this.template = React.createRef();
    this.__s.publicProp = void 0;
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default App;"
`;

exports[`Class bindings should compile @api props with default values 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./app.html\\";

class App extends React.Component {
  constructor(...args) {
    super(...args);

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({});
    }

    this.template = React.createRef();
    this.__s.publicProp = \\"some default\\";
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default App;"
`;

exports[`Class bindings should compile @api with a getter and styles 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./app.html\\";

class ProductImage extends React.Component {
  constructor(...args) {
    super(...args);

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({});
    }

    this.template = React.createRef();
    this.__s.imageUrl = void 0;
    this.__s.productName = \\"name\\";
  }

  get className() {
    return this.__s.productName;
  }

  get url() {
    if (this.__s.imageUrl) {
      return this.__s.imageUrl;
    }

    return \\"https://picsum.photos/200/300\\";
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default ProductImage;"
`;

exports[`Class bindings should compile method called from constructor 1`] = `
"import ObservableMembrane from \\"observable-membrane\\";
import React from \\"react\\";
import _tmpl from \\"./app.html\\";

class App extends React.Component {
  constructor() {
    super();

    const membrane = new ObservableMembrane({
      valueMutated: () => {
        if (this.mounted)
          this.forceUpdate();
      }
    });

    if (!this.__s) {
      this.__s = membrane.getProxy({
        doSomething: this.doSomething
      });
    }

    this.template = React.createRef();
    this.__s.wow = \\"hi2\\";
    this.__s.other = \\"hi3\\";
    this.doSomething();
  }

  doSomething() {
    this.__s.wow = \\"hi\\";
  }

  render() {
    return _tmpl(Object.assign(this, this.props, this.__s));
  }

  componentDidMount() {
    this.mounted = true;
    this.stylesheets = [];

    _tmpl.stylesheets.forEach(stylesheet => {
      const sheet = document.createElement(\\"style\\");
      sheet.type = \\"text/css\\";

      sheet.textContent = stylesheet(
        \\"[\\" + _tmpl.stylesheetTokens.hostAttribute.toLowerCase() + \\"]\\",
        \\"[\\" + _tmpl.stylesheetTokens.shadowAttribute.toLowerCase() + \\"]\\",
        null
      );

      document.head.appendChild(sheet);
      this.stylesheets.push(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this[ref] = this[ref].bind(this);
      this.template.current.addEventListener(name, this[ref]);
    });
  }

  componentWillUnmount() {
    this.mounted = false;

    this.stylesheets.forEach(sheet => {
      if (sheet.parentNode)
        sheet.parentNode.removeChild(sheet);
    });

    _tmpl.customEvents.forEach(event => {
      const name = event[0];
      const ref = event[1];
      this.template.current.removeEventListener(name, this[ref]);
    });
  }
}

export default App;"
`;
